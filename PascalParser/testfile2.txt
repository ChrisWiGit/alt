{sdgfsdfg}
unit ssdfsdfdf;

interface




type  
  TPersistentClass = class of TRegPersistent;

  TRegPersistent = class(TPersistent)
   fOwner : TRegPersistent;
  protected
    class procedure PutCsdflass(Stream: TStream);
    class function GetCasdflass(Stream: TStream): TPersistentClaasdfss;
  public
    constructor Create(aOwner : TRegPersistent); virtual;

    procedure InitLoad;
    procedure DoneLoad;
    procedure Load(Stream: TStream); virtual;
    procedure Store(Stream: TStream); virtual;

    property Owner : TRegPersistent read fOwner write fOwner;
  end;

implementation

resourcestring
  dasd = 'asd{as}df';


 type
TVTGetNodeProc = procedure(Sender: TBaseVirtualTree; Node: PVirtualNode; Data: Pointer; var Abort: Boolean) of object;
 

type
  VTEditLink = interface
    ['{2BE3EAFA-5ACB-45B4-9D9A-B58BCC496E17}']
    function BeginEdit: Boolean; stdcall;                  // called when editing actually starts
    function CancelEdit: Boolean; stdcall;                 // called when editing has been cancelled by the tree
    function EndEdit: Boolean; stdcall;                    // called when editing has been finished by the tree
    function PrepareEdit(Tree: TBaseVirtualTree; Node: PVirtualNode; Column: TColumnIndex): Boolean; stdcall;
                                                           // called after creation to allow a setup
    function GetBounds: TRect; stdcall;                    // called to get the current size of the edit window
                                                           // (only important if the edit resizes itself)
    procedure ProcessMessage(var Message: TMessage); stdcall;
                                                           // used to forward messages to the edit window(s)
    procedure SetBounds(R: TRect); stdcall;                // called to place the editor
  end;


type
IDropTargetHelper = interface(IUnknown)
    [SID_IDropTargetHelper]
    function DragEnter(hwndTarget: HWND; pDataObject: IDataObject; var ppt: TPoint; dwEffect: Integer): HRESULT;stdcall;
    function DragLeave: HRESULT;
    function DragOver(var ppt: TPoint; dwEffect: Integer): HRESULT;
    function Drop(pDataObject: IDataObject; var ppt: TPoint; dwEffect: Integer): HRESULT;
    function Show(fShow: Boolean): HRESULT;
  end;


var // Clipboard format IDs used in OLE drag'n drop and clipboard transfers.
  CF_VIRTUALTREE,
  CF_VTREFERENCE,
  CF_VRTF,
  CF_VRTFNOOBJS,   // Unfortunately CF_RTF* is already defined as being
                   // registration strings so I have to use different identifiers.
  CF_HTML,
  CF_CSV: Word;

  MMXAvailable: Boolean; // necessary to know because the blend code uses MMX instructions
  
type
   TVirtualNode = packed record
    Index,                   // index of node with regard to its parent
    ChildCount: Cardinal;    // number of child nodes
    NodeHeight: Word;        // height in pixels  end;
   end;


var s : ^String;


type
  // The exception used by the trees.
  PEVirtualTreeError = ^EVirtualTreeError;
  EVirtualTreeError = class(Exception);

  PCardinal = ^Cardinal;



//resourcestring
const  dasd = 'asd{as}df';

procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;
type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;




type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,b,c,d,e);




 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;


var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo



{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo


{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo



{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      '');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo


implementation

