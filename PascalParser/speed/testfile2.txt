{sdgfsdfg}
unit ssdfsdfdf;

interface


resourcestring
  dasd = 'asdfasdf';

procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;
type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;




type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;

const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,b,c,d,e);




 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;


var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo



{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo


{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo



{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo

{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo
{I .\..\PascalParser\include.inc}
procedure RaiseException(Msg : String; const Args: array of const);stdcall;external;



type sdf = packed class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;


const
     {SPascalWord ist ein genaues Abbild des Typs: @TPascalWord als Text.}
      SPascalWord : array[pw_none..pw_implementation] of ShortString =
      ('','unit','library','exports',
      'interface','type','const','var','out',
      'procedure','function','constructor','destructor',
      'register','pascal','forward','cdecl','deprecated','stdcall','overload','near','far','safecall','external','varargs','export',

      'set','array','of','case',
      'interface','dispinterface',
      'class','object','record','packed','begin','end',
      'property','private','protected','public','published','read','write','index','stored','default','override','virtual','reintroduce','abstract','dynamic','dispid','message',

      'implementation');

const  abc = pw_none..pw_implementation;

type zweiteklasse = class(adsf)
       {Löst eine Exception aus mit Dateinamen (sofern vorhanden),Zeilenangabe und dem Fehlertext Msg.}
       procedure RaiseException(Msg : String; Position : Cardinal = 0); overload;
       procedure RaiseException(Msg : String; const Args: array of const);overload;                    //asdasd
     end;



const
 {Methodendeklarationen, die hinter einer Methode auftauchen können}
      MethodDefinitions  : TPascalWords = [pw_message,pw_dispid,pw_default,pw_dynamic,pw_abstract,pw_override,pw_virtual,pw_reintroduce,pw_overload];



      {Funktionsdeklarationen, die hinter einem Funktionskopf auftauchen können}
      FuncDefinitions : TPascalWords = [pw_reintroduce,pw_register..pw_safecall,pw_varargs,pw_external];
      {Eigenschaftendeklarationen, die hinter Eigenschaften bei Klassen und Interfaces auftauchen können.}
      PropertyDefinitions :TPascalWords = [pw_dispid,pw_default,pw_read,pw_write,pw_index];

const fs = absolute of $FF;

{I F:\Projekte D7\PascalParser\IncludeParser\include.inc}

const
   DEBUGGER = 'SDF''';


type asdf = (a,//hello
 b,c,d,e);

 TTextStream = class(TMemoryStream)
     private
       {Erstellt ein MemoryStream mit den Inhalt der Datei Filename.
       Mode kann den Zugriff auf die Datei bestimmen, allerdings werden Schreibrechte
       nicht ausgeführt, weil eine Kopie der Daten in den Speicher geladen und dann verwendet wird.}
       constructor Create(const FileName: string; Mode: Word); overload; //Create a file

       {da property}
       property asdf; //uah
     end;



var asd : asf; //huoi

type df = asdf; //sdfg;

const sadf = 7; //hgsadfl
procedure ac(asd : ds asd = 0);stdcall;//hallo


implementation

