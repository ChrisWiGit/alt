<html><head><!--TOOLBAR_EXEMPT-->
	<meta http-equiv="Content-Type" content="text/html; charset=windows-1252"><title>Visual C++ ADO Programming ()</title>
    	
<meta name="Description" content="Microsoft® ActiveX® Data Objects (ADO) enable your client applications to access and manipulate data from a database server through an OLE DB provider. ADO supports key features for building client/server and Web-based applications.">
<meta name="Robots" content="">
<meta name="Keywords" content="">
<meta name="MS.LOCALE" content="en-us">

<link rel="stylesheet" type="text/css" href="mdhowhowvcusersshouldreadadodocumentation.asp_dateien/n6.css">
<link rel="stylesheet" type="text/css" href="mdhowhowvcusersshouldreadadodocumentation.asp_dateien/down.css">

<style type="text/css"><!--

	PRE.clsCode { font-size:110%; } 

	PRE.clsSyntax { font-size:100%; }  

--></style>

	<style>
	BODY
	{
		font-family:verdana,arial,helvetica;
		margin:0;
	}
	</style>
	
<script language="javascript" src="mdhowhowvcusersshouldreadadodocumentation.asp_dateien/ado.js"></script>
<script language="javascript" src="mdhowhowvcusersshouldreadadodocumentation.asp_dateien/toolbar.js"></script><layer visibility="hide"></layer><link rel="stylesheet" type="text/css" href="mdhowhowvcusersshouldreadadodocumentation.asp_dateien/tbmdac.css"><link rel="stylesheet" type="text/css" href="mdhowhowvcusersshouldreadadodocumentation.asp_dateien/dtue.css"><link rel="stylesheet" type="text/css" href="mdhowhowvcusersshouldreadadodocumentation.asp_dateien/default.css"><script language="JavaScript"><!--
   function BrowserData()
{
		this.userAgent = "Mozilla/5.0 (Windows; U; Windows NT 5.1; de-DE; rv:1.7) Gecko/20040803 Firefox/0.9.3";

		this.bot = false;

		this.browser = "Nav";

		this.majorVer = 5;

		this.minorVer = "0";

		this.platform = "NT";

		this.getsNavBar = false;

		this.doesActiveX = false;

		this.doesPersistence = false;

		this.fullVer = 5;

   }

   var oBD = new BrowserData();

   //--></script><script language="JavaScript"><!--

   if (document.layers) {
    origWidth  = innerWidth;
  origHeight = innerHeight;
   }

   function resizeFix() { if (innerWidth != origWidth || innerHeight != origHeight) location.reload(); }

   if (document.layers) onresize = resizeFix;

   //--></script><!-- base --><script language="JavaScript"><!--
   function BrowserData()
{
		this.userAgent = "Mozilla/5.0 (Windows; U; Windows NT 5.1; de-DE; rv:1.7) Gecko/20040803 Firefox/0.9.3";

		this.bot = false;

		this.browser = "Nav";

		this.majorVer = 5;

		this.minorVer = "0";

		this.platform = "NT";

		this.getsNavBar = false;

		this.doesActiveX = false;

		this.doesPersistence = false;

		this.fullVer = 5;

   }

   var oBD = new BrowserData();

   //--></script><script language="JavaScript"><!--

   if (document.layers) {
    origWidth  = innerWidth;
  origHeight = innerHeight;
   }

   function resizeFix() { if (innerWidth != origWidth || innerHeight != origHeight) location.reload(); }

   if (document.layers) onresize = resizeFix;

   //--></script><script>
	if( self == top )
{
	location = "/library/en-us/ado270/htm/mdhowhowvcusersshouldreadadodocumentation.asp";
}

</script><meta name="MSHTOCTitle" content="Visual C++ ADO Programming"><meta name="MSHRLTitle" content="Visual C++ ADO Programming"><meta name="MSHKeywordA" content="mdhowHowVCUsersShouldReadADODocumentation"><meta name="MSHKeywordA" content="mdhowHowVCUsersShouldReadADODocumentation"><meta name="MSHAttr" content="DocSet:PSDK"><meta name="MSHAttr" content="Locale:kbEnglish"><meta name="MSHAttr" content="Technology:ADO"><meta name="MSHAttr" content="Technology:MDAC"><meta name="MSHRLTitle" content="SafeArray" vtopic="mdmscSafeArray"><meta name="MSHKeywordA" content="mdmscSafeArray" vtopic="mdmscSafeArray"><meta name="MSHKeywordA" content="mdmscSafeArray" vtopic="mdmscSafeArray"><meta name="MSHAttr" content="DocSet:PSDK" vtopic="mdmscSafeArray"><meta name="MSHAttr" content="Locale:kbEnglish" vtopic="mdmscSafeArray"><meta name="MSHAttr" content="Technology:ADO" vtopic="mdmscSafeArray"><meta name="MSHAttr" content="Technology:MDAC" vtopic="mdmscSafeArray"><link rel="stylesheet" type="text/css" href="mdhowhowvcusersshouldreadadodocumentation.asp_dateien/css.css"><script language="javascript">
var doImage=doImage;var TType=TType;
function mhHover(tbl,idx,cls){var t,d;if(document.getElementById)t=document.getElementById(tbl);else t=document.all(tbl);if(t==null)return;if(t.getElementsByTagName)d=t.getElementsByTagName("TD");else d=t.all.tags("TD");if(d==null)return;if(d.length<=idx)return;d[idx].className=cls;}
function footerjs(doc){if(doImage==null){var tt=TType==null?"PV":TType;doc.write('<layer visibility="hide"><div style="display:none"><img src="http://c.microsoft.com/trans_pixel.asp?source=msdn&TYPE=' + tt + '&p=library_en-us_ado270_htm&r=http%3a%2f%2fmsdn.microsoft.com%2flibrary%2fshared%2fdeeptree%2fasp%2frightframe.asp%3fdtcfg%3d%2flibrary%2fdeeptreeconfig.xml%26url%3d%2flibrary%2fen-us%2fado270%2fhtm%2fmdhowhowvcusersshouldreadadodocumentation.asp%3fframe%3dtrue%26hidetoc%3dfalse" width=0 height=0 hspace=0 vspace=0 border=0 /></div></layer>');}}
</script></head>

<body topmargin="0" leftmargin="0" bgcolor="#ffffff" marginheight="0" marginwidth="0" text="#000000"><div style="display: none;"><img src="mdhowhowvcusersshouldreadadodocumentation.asp_dateien/trans_pixel_002.gif" border="0" height="0" hspace="0" vspace="0" width="0"></div>







   

   

   

   



<xml id="xmlPageContext"><eyebrow findmenu="false">
	<item label="MSDN Home" url="/default.asp">
	<item label="MSDN Library" url="/library/default.asp">
	<item label="Data Access" url="/library/en-us/dnanchor/html/anch_dataaccess.asp" id="msdnlib52" xmlsrc="/library/en-us/toc/msdnlib/msdnlib52_.xml"><item label="Reference" id="msdnlib71"><item label="Microsoft ActiveX Data Objects (ADO)" url="/library/en-us/ado270/htm/dasdkadooverview.asp" id="ado2702" xmlsrc="/library/en-us/toc/ado270/ado2702_.xml"><item label="ADO Programmer's Guide" url="/library/en-us/ado270/htm/mdmscadoprogrammersguide.asp" id="ado2706"><item label="Appendixes" url="/library/en-us/ado270/htm/mdmscsectionv_appendixes.asp" id="ado270208" xmlsrc="/library/en-us/toc/ado270/ado270208_.xml"><item label="Appendix C: Programming with ADO" url="/library/en-us/ado270/htm/mdmscprogrammingwithado.asp" id="ado270227" xmlsrc="/library/en-us/toc/ado270/ado270227_.xml"><item label="Using ADO with Microsoft Visual C++" url="/library/en-us/ado270/htm/mdmscusingadowithmicrosoftvisualc.asp" id="ado270232"><item label="Visual C++ ADO Programming" url="/library/en-us/ado270/htm/mdhowhowvcusersshouldreadadodocumentation.asp" id="ado270233"></item></item>

        <!--VENUS_START-->
        
        
        
        
        
        
        
        
<mshelp:vtopic name="mdmscSafeArray">
        
        
        
        
        
        
        

        <!---VENUS_END--->




 

       </mshelp:vtopic></item></item></item></item></item></item></item></item></eyebrow></xml><table bgcolor="#ffffff" border="0" cellpadding="4" cellspacing="0" height="24" width="100%">
       <tbody><tr>
        <td class="eyebrow" align="left" valign="middle" width="100%">  

            <a class="small" target="_top" href="http://msdn.microsoft.com/default.asp">MSDN Home</a> &gt; 
            <a class="small" target="_top" href="http://msdn.microsoft.com/library/default.asp">MSDN Library</a> &gt; 
            <a class="small" target="_top" href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnanchor/html/anch_dataaccess.asp">Data Access</a> &gt; 
            <a class="small" target="_top" href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/ado270/htm/dasdkadooverview.asp">Microsoft ActiveX Data Objects (ADO)</a> &gt; 
            <a class="small" target="_top" href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/ado270/htm/mdmscadoprogrammersguide.asp">ADO Programmer's Guide</a> &gt; 
            <a class="small" target="_top" href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/ado270/htm/mdmscsectionv_appendixes.asp">Appendixes</a> &gt; 
            <a class="small" target="_top" href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/ado270/htm/mdmscprogrammingwithado.asp">Appendix C: Programming with ADO</a> &gt; 
            <a class="small" target="_top" href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/ado270/htm/mdmscusingadowithmicrosoftvisualc.asp">Using ADO with Microsoft Visual C++</a><a href=""></a>
        </td>
       </tr>
       </tbody></table>
 <table class="clsContainer" float="left" border="0" cellpadding="15" cellspacing="0" width="100%"> <tbody><tr> <td valign="top">
<!--TOOLBAR_START-->
<!--TOOLBAR_EXEMPT-->
<!--TOOLBAR_END-->
<!-- Begin Content -->

<div id="scrbanner">
<div id="bannerrow1">
<table class="bannerparthead" cellspacing="0">
<tbody><tr id="hdr">
<td class="bannerparthead td" nowrap="nowrap">ADO 2.8 Appendixes</td><td valign="middle"><a href="#Feedback" target="_self"><img name="feedb" onclick="startFeedback(SDKFeedB)" style="" alt="" src="mdhowhowvcusersshouldreadadodocumentation.asp_dateien/mailto.gif" align="right" hspace="15"></a></td>
</tr>
</tbody></table>
</div>
</div>
<div id="scrtext" valign="bottom">
<h1 class="dtH1"><a name="mdhowhowvcusersshouldreadadodocumentation"></a>Visual C++ ADO Programming</h1>

<p>The ADO API Reference describes the functionality of the ADO
application programming interface (API) using a syntax similar to
Microsoft Visual Basic. Though the intended audience is all users, ADO
programmers employ diverse languages such as Visual Basic, Visual C++
(with and without the <b>#import</b> directive), and Visual J++ (with the ADO/WFC class package).</p>

<p>To accommodate this diversity, the <a href="http://msdn.microsoft.com/library/en-us/ado270/htm/mdmscusingadowithmicrosoftvisualc.asp">ADO for Visual C++ Syntax Indexes</a>
provide Visual C++ language-specific syntax with links to common
descriptions of functionality, parameters, exceptional behaviors, and
so on, in the API Reference.</p>

<p>ADO is implemented with COM (Component Object Model) interfaces.
However, it is easier for programmers to work with COM in certain
programming languages than others. For example, nearly all the details
of using COM are handled implicitly for Visual Basic programmers,
whereas Visual C++ programmers must attend to those details themselves.</p>

<p>The following sections summarize details for C and C++ programmers using ADO and the <b>#import</b> directive. It focuses on data types specific to COM (<b>Variant</b>, <b>BSTR</b>, and <b>SafeArray</b>), and error handling (_com_error).</p>

<h2 class="dtH2">Using the #import Compiler Directive</h2>

<p>The <b>#import</b> Visual C++ compiler directive simplifies working
with the ADO methods and properties. The directive takes the name of a
file containing a type library, such as the ADO .dll (Msado15.dll), and
generates header files containing typedef declarations, smart pointers
for interfaces, and enumerated constants. Each interface is
encapsulated, or wrapped, in a class. </p>

<p>For each operation within a class (that is, a method or property
call), there is a declaration to call the operation directly (that is,
the "raw" form of the operation), and a declaration to call the raw
operation and throw a COM error if the operation fails to execute
successfully. If the operation is a property, there is usually a
compiler directive that creates an alternative syntax for the operation
that has syntax like Visual Basic.</p>

<p>Operations that retrieve the value of a property have names of the form, <b>Get</b><i>Property</i>. Operations that set the value of a property have names of the form, <b>Put</b><i>Property</i>. Operations that set the value of a property with a pointer to an ADO object have names of the form, <b>PutRef</b><i>Property</i>. </p>

<p>You can get or set a property with calls of these forms:</p>

<pre class="code">variable = objectPtr-&gt;Get<i>Property</i>(); // get property value 
objectPtr-&gt;Put<i>Property</i>(<i>value</i>);       // set property value
objectPtr-&gt;PutRef<i>Property</i>(&amp;<i>value</i>);   // set property with object pointer</pre>

<h2 class="dtH2">Using Property Directives</h2>

<p>The <b>__declspec(property...)</b> compiler directive is a
Microsoft-specific C language extension that declares a function used
as a property to have an alternative syntax. As a result, you can set
or get values of a property in a way similar to Visual Basic. For
example, you can set and get a property this way:</p>

<pre class="code">objectPtr-&gt;<i>property</i> = <i>value</i>;        // set property value
variable = objectPtr-&gt;<i>property</i>;     // get property value</pre>

<p>Notice you do not have to code:</p>

<pre class="code">objectPtr-&gt;Put<i>Property</i>(<i>value</i>);      // set property value
variable = objectPtr-&gt;Get<i>Property</i>;  // get property value</pre>

<p>The compiler will generate the appropriate <b>Get</b><i>-</i>, <b>Put</b>-, or <b>PutRef</b><i>Property</i> call based on what alternative syntax is declared and whether the property is being read or written. </p>

<p>The <b>__declspec(property...)</b> compiler directive can only declare <b>get</b>, <b>put</b>, or <b>get</b> and <b>put</b> alternative syntax for a function. Read-only operations only have a <b>get</b> declaration; write-only operations only have a <b>put</b> declaration; operations that are both read and write have both <b>get</b> and <b>put</b> declarations.</p>

<p>Only two declarations are possible with this directive; however, each property may have three property functions: <b>Get</b><i>Property</i>, <b>Put</b><i>Property</i>, and <b>PutRef</b><i>Property</i>. In that case, only two forms of the property have the alternative syntax.</p>

<p>For example, the <b>Command</b> object <b>ActiveConnection</b> property is declared with an alternative syntax for <b>Get</b><i>ActiveConnection</i> and <b>PutRef</b><i>ActiveConnection</i>. The <b>PutRef</b>- syntax is a good choice because in practice, you will typically want to put an open <b>Connection</b> object (that is, a <b>Connection</b> object pointer) in this property. On the other hand, the <b>Recordset</b> object has <b>Get</b>-, <b>Put</b>-, and <b>PutRef</b><i>ActiveConnection</i> operations, but no alternative syntax.</p>

<h2 class="dtH2">Collections, the GetItem Method, and the Item Property</h2>

<p>ADO defines several collections, including <b>Fields</b>, <b>Parameters</b>, <b>Properties</b>, and <b>Errors</b>. In Visual C++, the <b>GetItem(</b><i>index</i><b>)</b> method returns a member of the collection. <i>Index</i> is a <b>Variant</b>, the value of which is either a numerical index of the member in the collection, or a string containing the name of the member.</p>

<p>The <b>__declspec(property...)</b> compiler directive declares the <b>Item</b> property as an alternative syntax to each collection's fundamental <b>GetItem() </b>method.
The alternative syntax uses square brackets and looks similar to an
array reference. In general, the two forms look like the following:</p>

<pre class="code"><i>collectionPtr-&gt;</i><code class="ce">GetItem(index);</code>
<i>collectionPtr</i><code class="ce">-&gt;Item[index];</code></pre>

<p>For example, assign a value to a field of a <b>Recordset</b> object, named <b><i>rs</i></b>, derived from the <b>authors</b> table of the <b>pubs</b> database. Use the <b>Item()</b> property to access the third <b>Field</b> of the <b>Recordset</b> object <b>Fields</b> collection (collections are indexed from zero; assume the third field is named <b><i>au_fname</i></b>). Then call the <b>Value()</b> method on the <b>Field</b> object to assign a string value.</p>

<p>This can be expressed in Visual Basic in the following four ways
(the last two forms are unique to Visual Basic; other languages do not
have equivalents):</p>

<pre class="code">rs.Fields.Item(2).Value = "<i>value</i>"
rs.Fields.Item("au_fname").Value = "<i>value</i>"
rs(2) = "<i>value</i>"
rs!au_fname = "<i>value</i>"</pre>

<p>The equivalent in Visual C++ to the first two forms above is:</p>

<pre class="code">rs-&gt;Fields-&gt;GetItem(long(2))-&gt;PutValue("<i>value</i>"); 
rs-&gt;Fields-&gt;GetItem("au_fname")-&gt;PutValue("<i>value</i>");</pre>

<p>-or- (the alternative syntax for the <b>Value</b> property is also shown)</p>

<pre class="code">rs-&gt;Fields-&gt;Item[long(2)]-&gt;Value = "<i>value</i>";
rs-&gt;Fields-&gt;Item["au_fname"]-&gt;Value = "<i>value</i>";</pre>

<p>For examples of iterating through a collection, see the "ADO Collections" section of "ADO Reference".</p>

<h2 class="dtH2">COM-Specific Data Types</h2>

<p>In general, any Visual Basic data type you find in the ADO API
Reference has a Visual C++ equivalent. These include standard data
types such as <b>unsigned char</b> for a Visual Basic <b>Byte</b>, <b>short</b> for <b>Integer</b>, and <b>long </b>for <b>Long</b>. Look in the Syntax Indexes<i> </i>to see exactly what is required for the operands of a given method or property.</p>

<p>The exceptions to this rule are the data types specific to COM: <b>Variant</b>, <b>BSTR</b>, and <b>SafeArray</b>.</p>

<h3 class="dtH3">Variant</h3>

<p>A <b>Variant</b> is a structured data type that contains a value member and a data type member. A <b>Variant</b>
may contain a wide range of other data types including another Variant,
BSTR, Boolean, IDispatch or IUnknown pointer, currency, date, and so
on. COM also provides methods that make it easy to convert one data
type to another. </p>

<p>The <b>_variant_t</b> class encapsulates and manages the <b>Variant</b> data type.</p>

<p>When the ADO API Reference says a method or property operand takes a value, it usually means the value is passed in a <b>_variant_t</b>.</p>

<p>This rule is explicitly true when the <b>Parameters</b> section in the topics of the ADO API Reference says an operand is a <b>Variant</b>. One exception is when the documentation explicitly says the operand takes a standard data type, such as <b>Long</b> or <b>Byte</b>, or an enumeration. Another exception is when the operand takes a <b>String</b>.</p>

<h3 class="dtH3">BSTR</h3>

<p>A <b>BSTR</b> (<b>B</b>asic <b>STR</b>ing) is a structured data type
that contains a character string and the string's length. COM provides
methods to allocate, manipulate, and free a <b>BSTR</b>.</p>

<p>The <b>_bstr_t</b> class encapsulates and manages the <b>BSTR</b> data type.</p>

<p>When the ADO API Reference says a method or property takes a <b>String</b> value, it means the value is in the form of a <b>_bstr_t</b>.</p>

<h3 class="dtH3">Casting _variant_t and _bstr_t Classes</h3>

<p>Often it is not necessary to explicitly code a <b>_variant_t</b> or <b>_bstr_t</b> in an argument to an operation. If the <b>_variant_t</b> or <b>_bstr_t</b> class has a constructor that matches the data type of the argument, then the compiler will generate the appropriate <b>_variant_t</b> or <b>_bstr_t</b>.</p>

<p>However, if the argument is ambiguous, that is, the argument's data
type matches more than one constructor, you must cast the argument with
the appropriate data type to invoke the correct constructor.</p>

<p>For example, the declaration for the <b>Recordset::Open</b> method is:</p>

<pre class="code">    HRESULT Open (
        const _variant_t &amp; Source,
        const _variant_t &amp; ActiveConnection,
        enum CursorTypeEnum CursorType,
        enum LockTypeEnum LockType,
        long Options );</pre>

<p>The <code class="ce">ActiveConnection </code>argument takes a reference to a <b>_variant_t</b>, which you may code as a connection string or a pointer to an open <b>Connection</b> object.</p>

<p>The correct <b>_variant_t</b> will be constructed implicitly if you pass a string such as "<code class="ce">DSN=pubs;uid=MyUserName;pwd=MyPassword;</code>", or a pointer such as "<code class="ce">(IDispatch *) pConn</code>".</p>

<p>Or you may explicitly code a <b>_variant_t</b> containing a pointer such as "<code class="ce">_variant_t((IDispatch *) pConn, true)</code>". The cast, <code class="ce">(IDispatch *)</code>, resolves the ambiguity with another constructor that takes a pointer to an IUnknown interface.</p>

<p>It is a crucial, though seldom mentioned fact, that ADO is an
IDispatch interface. Whenever a pointer to an ADO object must be passed
as a <b>Variant</b>, that pointer must be cast as a pointer to an IDispatch interface.</p>

<p>The last case explicitly codes the second boolean argument of the constructor with its optional, default value of <code class="ce">true</code>. This argument causes the <b>Variant</b> constructor to call its <b>AddRef</b>() method, which compensates for ADO automatically calling the <b>_variant_t::Release</b>() method when the ADO method or property call completes.</p>

<h3 class="dtH3"><a name="mdmscsafearray"></a>SafeArray</h3>

<p>A <b>SafeArray</b> is a structured data type that contains an array of other data types. A <b>SafeArray</b> is called <i>safe</i>
because it contains information about the bounds of each array
dimension, and limits access to array elements within those bounds.</p>

<p>When the ADO API Reference says a method or property takes or
returns an array, it means the method or property takes or returns a <b>SafeArray</b>, not a native C/C++ array.</p>

<p>For example, the second parameter of the <b>Connection</b> object <b>OpenSchema</b> method requires an array of <b>Variant</b> values. Those <b>Variant</b> values must be passed as elements of a <b>SafeArray</b>, and that <b>SafeArray</b> must be set as the value of another <b>Variant</b>. It is that other <b>Variant</b> that is passed as the second argument of <b>OpenSchema</b>.</p>

<p>As further examples, the first argument of the <b>Find</b> method is a <b>Variant</b> whose value is a one-dimensional <b>SafeArray</b>; each of the optional first and second arguments of <b>AddNew</b> is a one-dimensional <b>SafeArray</b>; and the return value of the <b>GetRows</b> method is a <b>Variant</b> whose value is a two-dimensional <b>SafeArray</b>.</p>

<h2 class="dtH2">Missing and Default Parameters</h2>

<p>Visual Basic allows missing parameters in methods. For example, the <b>Recordset</b> object <b>Open</b> method has five parameters, but you can skip intermediate parameters and leave off trailing parameters. A default <b>BSTR</b> or <b>Variant</b> will be substituted depending on the data type of the missing operand.</p>

<p>In C/C++, all operands must be specified. If you want to specify a missing parameter whose data type is a string, specify a <b>_bstr_t</b> containing a null string. If you want to specify a missing parameter whose data type is a <b>Variant</b>, specify a <b>_variant_t</b> with a value of DISP_E_PARAMNOTFOUND and a type of VT_ERROR. Alternatively, specify the equivalent <b>_variant_t</b> constant, <b>vtMissing</b>, which is supplied by the <b>#import</b> directive.</p>

<p>Three methods are exceptions to the typical use of <b>vtMissing</b>. These are the <b>Execute</b> methods of the <b>Connection</b> and <b>Command</b> objects, and the <b>NextRecordset</b> method of the <b>Recordset</b> object. The following are their signatures:</p>

<pre class="code">_RecordsetPtr <a href="http://msdn.microsoft.com/library/en-us/ado270/htm/mdmthcnnexecute.asp">Execute</a>( _bstr_t <i>CommandText</i>, VARIANT * <i>RecordsAffected</i>, 
        long<i> Options </i>);  // Connection
_RecordsetPtr <a href="http://msdn.microsoft.com/library/en-us/ado270/htm/mdmthcmdexecute.asp">Execute</a>( VARIANT * <i>RecordsAffected</i>, VARIANT * <i>Parameters</i>, 
        long<i> Options </i>);  // Command
_RecordsetPtr <a href="http://msdn.microsoft.com/library/en-us/ado270/htm/mdmthnextrec.asp">NextRecordset</a>( VARIANT *<i> RecordsAffected </i>);  // Recordset</pre>

<p>The parameters, <i><code>RecordsAffected</code></i> and <i><code>Parameters</code></i>, are pointers to a <b>Variant</b>. <i><code>Parameters</code></i> is an input parameter which specifies the address of a <b>Variant</b> containing a single parameter, or array of parameters, that will modify the command being executed. <i><code>RecordsAffected </code></i>is an output parameter that specifies the address of a <b>Variant</b>, where the number of rows affected by the method is returned. </p>

<p>In the <b>Command</b> object <b>Execute</b> method, indicate that no parameters are specified by setting <i><code>Parameters</code></i> to either <code class="ce">&amp;vtMissing</code> (which is recommended) or to the null pointer (that is, <b>NULL</b> or zero (0)). If <i><code>Parameters</code></i> is set to the null pointer, the method internally substitutes the equivalent of <b>vtMissing</b>, and then completes the operation. </p>

<p>In all the methods, indicate that the number of records affected should not be returned by setting <i><code>RecordsAffected </code></i>to
the null pointer. In this case, the null pointer is not so much a
missing parameter as an indication that the method should discard the
number of records affected.</p>

<p>Thus, for these three methods, it is valid to code something such as:</p>

<pre class="code">pConnection-&gt;Execute("<i>commandText</i>", NULL, adCmdText); 
pCommand-&gt;Execute(NULL, NULL, adCmdText);
pRecordset-&gt;NextRecordset(NULL);</pre>

<h2 class="dtH2">Error Handling</h2>

<p>In COM, most operations return an HRESULT return code that indicates whether a function completed successfully. The <b>#import</b>
directive generates wrapper code around each "raw" method or property
and checks the returned HRESULT. If the HRESULT indicates failure, the
wrapper code throws a COM error by calling _com_issue_errorex() with
the HRESULT return code as an argument. COM error objects can be caught
in a <b>try</b>-<b>catch</b> block. (For efficiency's sake, catch a reference to a <b>_com_error</b> object.)</p>

<p>Remember, these are ADO errors: they result from the ADO operation
failing. Errors returned by the underlying provider appear as <b>Error</b> objects in the <b>Connection</b> object <b>Errors</b> collection.</p>

<p>The <b>#import</b> directive creates only error handling routines
for methods and properties declared in the ADO .dll. However, you can
take advantage of this same error handling mechanism by writing your
own error checking macro or inline function. See the topic, <a href="http://msdn.microsoft.com/library/en-us/ado270/htm/mdmscadovcextensions.asp">Visual C++ Extensions</a>, or the code in the following sections for examples.</p>

<h2 class="dtH2">Visual C++ Equivalents of Visual Basic Conventions</h2>

<p>The following is a summary of several conventions in the ADO
documentation, coded in Visual Basic, as well as their equivalents in
Visual C++.</p>

<h3 class="dtH3">Declaring an ADO Object</h3>

<p>In Visual Basic, an ADO object variable (in this case for a <b>Recordset</b> object) is declared as follows:</p>

<pre class="code">Dim rst As ADODB.Recordset</pre>

<p>The clause, "<code class="ce">ADODB.Recordset</code>", is the ProgID of the <b>Recordset</b> object as defined in the Registry. A new instance of a <b>Record</b> object is declared as follows:</p>

<pre class="code">Dim rst As New ADODB.Recordset</pre>

<p>-or-</p>

<pre class="code">Dim rst As ADODB.Recordset
Set rst = New ADODB.Recordset</pre>

<p>In Visual C++, the <b>#import </b>directive generates smart pointer-type declarations for all the ADO objects. For example, a variable that points to a <b>_Recordset</b> object is of type <b>_RecordsetPtr</b>, and is declared as follows:</p>

<pre class="code">_RecordsetPtr  rs;</pre>

<p>A variable that points to a new instance of a <b>_Recordset</b> object is declared as follows:</p>

<pre class="code">_RecordsetPtr  rs("ADODB.Recordset");</pre>

<p>-or-</p>

<pre class="code">_RecordsetPtr  rs;
rs.CreateInstance("ADODB.Recordset");</pre>

<p>-or-</p>

<pre class="code">_RecordsetPtr  rs;
rs.CreateInstance(__uuidof(_Recordset));</pre>

<p>After the <b>CreateInstance</b> method is called, the variable can be used as follows:</p>

<pre class="code">rs-&gt;Open(...);</pre>

<p>Notice that in one case, the "<code class="ce">.</code>" operator is used as if the variable were an instance of a class (<code class="ce">rs.CreateInstance</code>), and in another case, the "<code class="ce">-&gt;</code>" operator is used as if the variable were a pointer to an interface (<code class="ce">rs-&gt;Open</code>).</p>

<p>One variable can be used in two ways because the "<code class="ce">-&gt;</code>"
operator is overloaded to allow an instance of a class to behave like a
pointer to an interface. A private class member of the instance
variable contains a pointer to the <b>_Recordset</b> interface; the "<code class="ce">-&gt;</code>" operator returns that pointer; and the returned pointer accesses the members of the <b>_Recordset</b> object.</p>

<h3 class="dtH3">Coding a Missing Parameter  String</h3>

<p>When you need to code a missing <b>String</b> operand in Visual Basic, you merely omit the operand. You must specify the operand in Visual C++. Code a <b>_bstr_t</b> that has an empty string as a value.</p>

<pre class="code">_bstr_t strMissing(L"");</pre>

<h3 class="dtH3">Coding a Missing Parameter  Variant</h3>

<p>When you need to code a missing <b>Variant</b> operand in Visual Basic, you merely omit the operand. You must specify all operands in Visual C++. Code a missing <b>Variant</b> parameter with a <b>_variant_t</b> set to the special value, DISP_E_PARAMNOTFOUND, and type, VT_ERROR. Alternatively, specify <b>vtMissing</b>, which is an equivalent pre-defined constant supplied by the <b>#import</b> directive.</p>

<pre class="code">_variant_t  vtMissingYours(DISP_E_PARAMNOTFOUND, VT_ERROR); </pre>

<p>-or use -</p>

<pre class="code">...vtMissing...;</pre>

<h3 class="dtH3">Declaring a Variant</h3>

<p>In Visual Basic, a <b>Variant</b> is declared with the <b>Dim</b> statement as follows:</p>

<pre class="code">Dim <i>VariableName</i> As Variant</pre>

<p>In Visual C++, declare a variable as type <b>_variant_t</b>. A few schematic <b>_variant_t </b>declarations are shown below.</p>

<blockquote class="dtBlock">
<b class="le">Note   </b>These declarations merely give a rough idea of
what you would code in your own program. For more information, see the
examples below, and the Visual C++<i> </i>documentation.</blockquote>

<pre class="code">_variant_t  VariableName(<i>value</i>);
_variant_t  VariableName((<i>data type cast</i>) <i>value</i>);
_variant_t  VariableName(<i>value, </i>VT<i>_DATATYPE</i>);
_variant_t  VariableName(interface * <i>value, </i>bool fAddRef = true);</pre>

<h3 class="dtH3">Using Arrays of Variants</h3>

<p>In Visual Basic, arrays of <b>Variants</b> can be coded with the <b>Dim</b> statement, or you may use the <b>Array</b> function, as demonstrated in the following example code:</p>

<pre class="code">Public Sub ArrayOfVariants
Dim cn As ADODB.Connection
Dim rs As ADODB.Recordset
Dim fld As ADODB.Field

    cn.Open "DSN=pubs"
    rs = cn.OpenSchema(adSchemaColumns, _
        Array(Empty, Empty, "authors", Empty))
    For Each fld in rs.Fields
        Debug.Print "Name = "; fld.Name
    Next fld
    rs.Close
    cn.Close
End Sub</pre>

<p>The following Visual C++ example demonstrates using a <b>SafeArray</b> used with a <b>_variant_t</b>.</p>

<blockquote class="dtBlock">
<b class="le">Notes   </b>The following notes correspond to commented sections in the code example.</blockquote>

<blockquote class="dtBlock">
1.  Once again, the TESTHR() inline function is defined to take advantage of the existing error-handling mechanism.</blockquote>

<blockquote class="dtBlock">
2.  You only need a one-dimensional array, so you can use <b>SafeArrayCreateVector</b>, instead of the general purpose <b>SAFEARRAYBOUND</b> declaration and <b>SafeArrayCreate</b> function. The following is what that code would look like using <b>SafeArrayCreate</b>:</blockquote>

<pre class="code">   SAFEARRAYBOUND   sabound[1];
   sabound[0].lLbound = 0;
   sabound[0].cElements = 4;
   pSa = SafeArrayCreate(VT_VARIANT, 1, sabound);</pre>

<blockquote class="dtBlock">
3.  The schema identified by the enumerated constant, <b>adSchemaColumns</b>, is associated with four constraint columns: TABLE_CATALOG, TABLE_SCHEMA, TABLE_NAME, and COLUMN_NAME. Therefore, an array of <b>Variant</b> values with four elements is created. Then a constraint value that corresponds to the third column, TABLE_NAME, is specified.</blockquote>

<p>The <b>Recordset</b> that is returned consists of several columns, a
subset of which is the constraint columns. The values of the constraint
columns for each returned row must be the same as the corresponding
constraint values.</p>

<blockquote class="dtBlock">
4.  Those familiar with <b>SafeArrays </b>may be surprised that <b>SafeArrayDestroy</b>() is not called before the exit. In fact, calling <b>SafeArrayDestroy</b>() in this case will cause a run-time exception. The reason is that the destructor for <code class="ce">vtCriteria</code> will call <b>VariantClear</b>() when the <b>_variant_t </b>goes out of scope, which will free the <b>SafeArray</b>. Calling <b>SafeArrayDestroy</b>, without manually clearing the <b>_variant_t</b>, would cause the destructor to try to clear an invalid <b>SafeArray</b> pointer.</blockquote>

<p>If <b>SafeArrayDestroy</b> were called, the code would look like this:</p>

<pre class="code">   TESTHR(SafeArrayDestroy(pSa));
   vtCriteria.vt = VT_EMPTY;
   vtCriteria.parray = NULL;</pre>

<p>However, it is much simpler to let the <b>_variant_t</b> manage the <b>SafeArray</b>.</p>

<pre class="code">#import "msado15.dll" \
   no_namespace rename("EOF", "EndOfFile")
#include &lt;stdio.h&gt;

// Note 1
inline void TESTHR( HRESULT _hr ) 
   { if FAILED(_hr) _com_issue_error(_hr); }

void main(void)
{
   CoInitialize(NULL);
   try 
   {
   _RecordsetPtr   pRs("ADODB.Recordset");
   _ConnectionPtr  pCn("ADODB.Connection");
   _variant_t      vtTableName("authors"),
                   vtCriteria;
   long            ix[1];
   SAFEARRAY       *pSa = NULL;

   pCn-&gt;Open("DSN=pubs;Integrated Security=SSPI;
      Provider=MSDASQL;", "", "", 
               adConnectUnspecified);
// Note 2, Note 3
   pSa = SafeArrayCreateVector(VT_VARIANT, 1, 4);
   if (!pSa) _com_issue_error(E_OUTOFMEMORY);

// Specify TABLE_NAME in the third array element (index of 2). 

   ix[0] = 2;      
   TESTHR(SafeArrayPutElement(pSa, ix, &amp;vtTableName));

//   There is no Variant constructor for a SafeArray, so manually set the 
//   type (SafeArray of Variant) and value (pointer to a SafeArray).

   vtCriteria.vt = VT_ARRAY | VT_VARIANT;
   vtCriteria.parray = pSa;

   pRs = pCn-&gt;OpenSchema(adSchemaColumns, vtCriteria, vtMissing);

   long limit = pRs-&gt;GetFields()-&gt;Count;
   for (long x = 0; x &lt; limit; x++)
      printf("%d: %s\n", x+1, 
         ((char*) pRs-&gt;GetFields()-&gt;Item[x]-&gt;Name));
// Note 4
   pRs-&gt;Close();
   pCn-&gt;Close();
   }
   catch (_com_error &amp;e)
   {
   printf("Error:\n");
   printf("Code = %08lx\n", e.Error());
   printf("Code meaning = %s\n", (char*) e.ErrorMessage());
   printf("Source = %s\n", (char*) e.Source());
   printf("Description = %s\n", (char*) e.Description());
   }
   CoUninitialize();
}</pre>

<h3 class="dtH3">Using Property Get/Put/PutRef</h3>

<p>In Visual Basic, the name of a property is not qualified by whether it is retrieved, assigned, or assigned a reference.</p>

<pre class="code"><code class="ce">Public Sub GetPutPutRef
Dim rs As New ADODB.Recordset
Dim cn As New ADODB.Connection
Dim sz as Integer
cn.Open "</code>Provider=sqloledb;Data Source=yourserver;" &amp; _
         "Initial Catalog=pubs;Integrated Security=SSPI;<code class="ce">"</code>
<code class="ce">rs.PageSize = 10</code>
<code class="ce">sz = rs.PageSize</code>
<code class="ce">rs.ActiveConnection = cn</code>
<code class="ce">rs.Open "authors",,adOpenStatic</code>
<code class="ce">' ...</code>
<code class="ce">rs.Close</code>
<code class="ce">cn.Close</code>
<code class="ce">End Sub</code></pre>

<p>This Visual C++ example demonstrates the <b>Get</b>/<b>Put</b>/<b>PutRef</b><i>Property</i>.</p>

<blockquote class="dtBlock">
<b class="le">Notes   </b>The following notes correspond to commented sections in the code example.</blockquote>

<blockquote class="dtBlock">
1.  This example uses two forms of a missing string argument: an explicit constant, <b>strMissing</b>, and a string that the compiler will use to create a temporary <b>_bstr_t</b> that will exist for the scope of the <b>Open</b> method.</blockquote>

<blockquote class="dtBlock">
2.  It isn't necessary to cast the operand of <code class="ce">rs-&gt;PutRefActiveConnection(cn)</code> to <code class="ce">(IDispatch *)</code> because the type of the operand is already <code class="ce">(IDispatch *)</code>.</blockquote>

<pre class="code">#import "msado15.dll" \
   no_namespace rename("EOF", "EndOfFile")
#include &lt;stdio.h&gt;

void main(void)
{
   CoInitialize(NULL);
   try 
   {
      _ConnectionPtr  cn("ADODB.Connection");
      _RecordsetPtr   rs("ADODB.Recordset");
      _bstr_t         strMissing(L"");
      long            oldPgSz = 0, 
                      newPgSz = 5;

// Note 1
      cn-&gt;Open("Provider=sqloledb;Data Source=MyServer;"
         "Initial Catalog=pubs;Integrated Security=SSPI;", 
         strMissing, "",
         adConnectUnspecified);
   
      oldPgSz = rs-&gt;GetPageSize();
   // -or-
      oldPgSz = rs-&gt;PageSize;

      rs-&gt;PutPageSize(newPgSz);
   // -or-
      rs-&gt;PageSize = newPgSz;

// Note 2
      rs-&gt;PutRefActiveConnection( cn );
      rs-&gt;Open("authors", vtMissing, adOpenStatic, adLockReadOnly,
               adCmdTable);
      printf("Original pagesize = %d, new pagesize = %d\n", oldPgSz, 
               rs-&gt;GetPageSize());
      rs-&gt;Close();
      cn-&gt;Close();
   }
   catch (_com_error &amp;e)
   {
      printf("Description = %s\n", (char*) e.Description());
   }
   ::CoUninitialize();
}</pre>

<h3 class="dtH3">Using GetItem(x) and Item[x]</h3>

<p>This Visual Basic example demonstrates the standard and alternative syntax for <b>Item</b>().</p>

<pre class="code">Public Sub GetItemItem
Dim rs As New ADODB.Recordset
Dim name as String
rs = rs.Open "authors", "DSN=pubs;", adOpenDynamic, _
         adLockBatchOptimistic, adTable
name = rs(0)
' -or-
name = rs.Fields.Item(0)
rs(0) = "Test"
rs.UpdateBatch
' Restore name
rs(0) = name
rs.UpdateBatch
rs.Close
End Sub</pre>

<p>This Visual C++ example demonstrates <b>Item</b>.</p>

<blockquote class="dtBlock">
<b class="le">Note   </b>The following note corresponds to commented sections in the code example.</blockquote>

<blockquote class="dtBlock">
1.  When the collection is accessed with <b>Item</b>, the index, <b>2</b>, must be cast to <b>long </b>so an appropriate constructor will be invoked.</blockquote>

<pre class="code">#import "msado15.dll" \
   no_namespace rename("EOF", "EndOfFile")
#include &lt;stdio.h&gt;

void main(void)
{
   CoInitialize(NULL);
   try {
      _RecordsetPtr   rs("ADODB.Recordset");
      _variant_t      vtFirstName;

      rs-&gt;Open("authors",
               "Provider=sqloledb;Data Source=MyServer;"
               "Initial Catalog=pubs;Integrated Security=SSPI;",
               adOpenStatic, adLockOptimistic, adCmdTable);
      rs-&gt;MoveFirst();

// Note 1. Get a field.
      vtFirstName = rs-&gt;Fields-&gt;GetItem((long)2)-&gt;GetValue();
   // -or-
      vtFirstName = rs-&gt;Fields-&gt;Item[(long)2]-&gt;Value;

      printf( "First name = '%s'\n", (char*) ((_bstr_t) vtFirstName));

      rs-&gt;Fields-&gt;GetItem((long)2)-&gt;Value = L"TEST";
      rs-&gt;Update(vtMissing, vtMissing);

   // Restore name
      rs-&gt;Fields-&gt;GetItem((long)2)-&gt;PutValue(vtFirstName);
      // -or-
      rs-&gt;Fields-&gt;GetItem((long)2)-&gt;Value = vtFirstName;
      rs-&gt;Update(vtMissing, vtMissing);
      rs-&gt;Close();
   }
   catch (_com_error &amp;e)
   {
      printf("Description = '%s'\n", (char*) e.Description());
   }
   ::CoUninitialize();
}</pre>

<h3 class="dtH3">Casting ADO object pointers with (IDispatch *)</h3>

<p>The following Visual C++ example demonstrates using (IDispatch *) to cast ADO object pointers.</p>

<blockquote class="dtBlock">
<b class="le">Notes   </b>The following notes correspond to commented sections in the code example.</blockquote>

<blockquote class="dtBlock">
1.  Specify an open <b>Connection</b> object in an explicitly coded <b>Variant</b>. Cast it with (IDispatch *) so the correct constructor will be invoked. Also, explicitly set the second <b>_variant_t</b> parameter to the default value of <b>true</b>, so the object reference count will be correct when the <b>Recordset::Open</b> operation ends.</blockquote>

<blockquote class="dtBlock">
2.  The expression, <code class="ce">(_bstr_t)</code>, is not a cast, but a <b>_variant_t</b> operator that extracts a <b>_bstr_t </b>string from the <b>Variant</b> returned by <b>Value</b>.</blockquote>

<blockquote class="dtBlock">
The expression, <code class="ce">(char*)</code>, is not a cast, but a <b>_bstr_t</b> operator that extracts a pointer to the encapsulated string in a <b>_bstr_t</b> object.</blockquote>

<blockquote class="dtBlock">
This section of code demonstrates some of the useful behaviors of <b>_variant_t</b> and <b>_bstr_t</b> operators.</blockquote>

<pre class="code">#import "msado15.dll" \
no_namespace rename("EOF", "EndOfFile")

#include &lt;stdio.h&gt;

void main(void)
{
   CoInitialize(NULL);
   try 
   {
      _ConnectionPtr pConn("ADODB.Connection");
      _RecordsetPtr  pRst("ADODB.Recordset");

      pConn-&gt;Open("Provider=sqloledb;Data Source=MyServer;"
         "Initial Catalog=pubs;Integrated Security=SSPI;", 
         "", "", adConnectUnspecified);
// Note 1.
      pRst-&gt;Open(
         "authors",
         _variant_t((IDispatch *) pConn, true),
         adOpenStatic,
         adLockReadOnly,
         adCmdTable);
      pRst-&gt;MoveLast();
// Note 2.
      printf("Last name is '%s %s'\n", 
            (char*) ((_bstr_t) pRst-&gt;GetFields()-&gt;GetItem("au_fname")-&gt;GetValue()),
            (char*) ((_bstr_t) pRst-&gt;Fields-&gt;Item["au_lname"]-&gt;Value));

      pRst-&gt;Close();
      pConn-&gt;Close();
   }
   catch (_com_error &amp;e)
   {
      printf("Description = '%s'\n", (char*) e.Description());
   }   
::CoUninitialize();
}</pre>
<h4><a name="feedback"></a></h4>
<span id="SDKFeedB"></span>
</div>
<p align="center"><a href="http://msdn.microsoft.com/library/en-us/ado270/htm/ado_sdk_copyright_and_trademarks.asp">© 1998-2004 Microsoft Corporation. All rights reserved.</a></p>
<!--Monday, March 29, 2004-->
<!--4:34 PM-->


<!-- End Content -->

 </td> </tr> </tbody></table><br style="line-height: 1px; overflow: hidden;" clear="all"><table id="msviFooter" cellpadding="0" cellspacing="0" width="100%"><tbody><tr valign="bottom"><td id="msviFooter2" style=""><div id="msviLocalFooter"><nobr><a href="http://go.microsoft.com/?linkid=317027">Manage Your Profile</a> |</nobr><wbr><nobr><a href="http://msdn.microsoft.com/isapi/gomscom.asp?target=/legal/" target="_parent">Legal</a> |</nobr><wbr><nobr><a href="http://register.microsoft.com/contactus30/contactus.asp?domain=msdn" target="_parent">Contact Us</a> |</nobr><wbr><nobr><a href="http://msdn.microsoft.com/flash/" target="_parent">MSDN Flash Newsletter</a></nobr></div><div id="msviGlobalFooter"><span dir="ltr">©2005 Microsoft Corporation. All rights reserved. </span><nobr><a href="http://www.microsoft.com/info/cpyright.mspx">Terms of Use</a> |</nobr><wbr><nobr><a href="http://msdn.microsoft.com/library/toolbar/3.0/trademarks/en-us.mspx">Trademarks</a> |</nobr><wbr><nobr><a href="http://www.microsoft.com/info/privacy.mspx">Privacy Statement</a></nobr></div></td><td bgcolor="#669aff" width="105"><img src="mdhowhowvcusersshouldreadadodocumentation.asp_dateien/text.jpg" alt="Microsoft" title="" border="0" height="29" width="105"></td></tr></tbody></table>
<script language="javascript">footerjs(document);</script><layer visibility="hide"></layer><div style="display: none;"><img src="mdhowhowvcusersshouldreadadodocumentation.asp_dateien/trans_pixel.gif" border="0" height="0" hspace="0" vspace="0" width="0"></div>
 </body></html>